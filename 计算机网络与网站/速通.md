真的是没办法了，请你扮演一个严格的老师，阅读一下我随手做的笔记，之后提供一些建议，接着，你再提出一些计算机网络相关的面试题。考一下我。

##  网络分层

网络分为七层，但是，七层分得太细了，一般我们可以认为分为四层。

- 网络接口层
  - 包括物理层
  - 数据链路层
- 网络层
  - 一般也就是负责IP寻址的这一块
- 传输层，
  - 也就是TCP/UDP这一层。
- 应用层，我们学习计算机网络的时候，也是按照这五层的顺序

## 为什么网络需要分层？

1. 分层方便我们控制，。
2. 分层之后，提供了灵活性和可替换性。
3. 分层之后，各层相互独立。
4. 分层之后，相当于把大问题变成了小问题。

## 从输入URL到页面展示到底发生了什么。

简单地说，一般都不简单。
1. 首先是浏览器发起请求，
2. DNS服务器解析域名，返回IP
3. 根据IP & 端口号 发起TCP请求
4. 三次握手，建立联系
5. 在联系的基础上再发起HTTPS/HTTP请求，
6. 服务器根据请求响应HTTP报文
7. 浏览器解析HTTP报文，再发起请求，得到需要的资源
8. 渲染页面
9. 可以按需关闭页面。

其实上面回答省略了很多步骤，就比如说，我们的请求究竟是如何在物理链路当中传递的，DNS是怎么解析的，TCP的三次请求是怎样建立的。

## HTTP Status Code
常见的主要是
2XX，成功
3XX 重定向
4XX 客户端错误
5XX 服务器内部错误

## Header
我这一次只是记录几个比较常见的吧。

1. Accept: text/plain
2. Accept-Charst: utf-8
3. Accept-Encoding: gzip
4. Authorization
5. Cookie

## HTTP vs HTTPS
1. 端口号不同
2. URL不同，很明显的http & https 
3. 安全性和资源消耗不同
  - 我们HTTP是非常简单的，运行在TCP上面，传输的是明文，无法验证对方的身份。
  - 但是HTTPS就不一样，它很高级，基于SSL/TLS之上的HTTP协议，经过加密，加密本身是普通的对称加密，但是密钥使用了服务器方的证书进行了非对称加密，所以，也显然，需要耗费更多的资源。
  - SEO优化，浏览器偏好HTTPS的网站

## HTTP/1.0 vs HTTP/1.1 

1. 连接方式
2. 状态码
3. 缓存机制
4. 带宽
5. Host头

## HTTP/1.1 vs HTTP/2.0

1. 多路复用，一次连接可以执行多次请求和响应，互不干扰，可以看做是HTTP/1.1的升级版
2. 二进制帧，HTTP/2.0 传输的内容是二进制帧，压缩更紧密，
3. 解决了头部阻塞，因为多路复用。
4. 头部压缩， HTTP/1.1 不支持`Header` 的压缩，所以很难受。但是我们的HTTP/2.0就支持了。
5. 服务器推送，服务器知道你请求了HTML肯定还需要CSS，于是打包送给你了。

## HTTP/2.0 vs HTTP/3.0

1. 传输协议发生了改变，HTTP/3.0基于QUIC
2. 连接建立的方式也不再一样。HTTP/3.0深刻可以不再需要握手。
3. 头部压缩的算法也变得不一样。
4. 连接迁移的方式也不一样，HTTP/3.0基于64位的ID，所以即使中途改变了网络环境，连接也可以不中断。
5. 头部阻塞，即使出现了丢包，也仅仅停下一个数据流，不会影响其他的数据流
6. 错误恢复，HTTP/3.0的错误恢复机制更加友好。
7. 安全性，HTTP/3.0的加密机制会把整个包包括报文头和报文体都进行加密，更安全。

| 方面 | HTTP/1.1队头阻塞 | HTTP/2.0队头阻塞 |
| --------------- | --------------- | --------------- |
| 层级 | 应用层(协议本身的限制) | 传输层(TCP协议的限制) |
| 根本原因 | 无法多路复用，并需要按照顺序传输 | 要求按照顺序交付，丢包就会阻塞 |
|受影响的范围|单个HTTP请求会阻塞后续所有请求|单个丢包会影响所有流|
|缓解方法|并行多个TCP连接|减少丢包|
|影响场景|所有情况，尤其是大文件传输的情况|丢包率较高的情况下|

## HTTP怎么保存用户状态


### Session & Cookie (主流方法)(())

1. 用户向服务器发送验证的信息
2. 服务器验证身份，建立一个Session，保存用户信息，生成用户的Session ID
3. 服务器返回Session ID，使用响应头的Set-Session字段
4. 浏览器保存字段
5. 当用户保持登录状态的时候，再继续登录，浏览器就会在Cookie当中携带这个字段
6. 浏览器解析字段，完成身份的校验

### 注意事项
- 客户端浏览器需要支持Cookie
- Session过期管理
- Session ID 的安全管理

Session的另外还有存储方式
- 服务器内存：简单，快速，但是不能持久化，而且无法处理多服务器的问题。
- 数据库，读写性能很低
- 分布式缓存，主流方案。

### 重写URL
当Cookie无法使用的时候，我们就直接把Session ID 写在 URL 当中，但是这样的危害太大。安全性很差。

### Token-based (eg JWT-JSON Web Token)

- 特点，无状态
- 用户向服务器发送验证的信息
- 服务器解析信息，成功就返回已经签名的JWT
- 用户保存JWT
- 用户再访问的时候，就携带JWT
- 因为JWT里面已经有了很多信息，所以就不需要在服务器这一端保存其他的信息。

参考这个知乎的回答，里面提到了一些关于HTTP的GET & POST的差异。https://www.zhihu.com/question/28586791

还是很多启发的，就比如说，我们伟大的Elasticsearch，使用的就是「GET」，但是照样可以传递非常复杂的语义。因为语义太复杂，所以我们使用JSON

### 问题
HTTPS vs HTTP 相比于 HTTP自己的更新迭代，这之间的关系究竟是什么，HTTPS和HTTP自己的迭代有什么对应的吗？

## WebSocket

### ✅内涵
我们可爱的Websocket的内涵是什么？
我认为，WebSocket不需要什么内涵。
说起来，这个东西还是我入门Web的开端，我一开始就是写Python Django，那时候就使用了这个协议。
它是基于HTTP实现的，实质上是建立一个长连接，之后就不需要再总是验证。

### 和HTTP的区别

1. WebSocket 是一种双向的实时通信协议， HTTP 单向通信协议，只能由客户端发起，服务器不能发送
2. WebSocket 使用ws:// || wss:// ，协议也不相同
3. WebSocket的扩展性很好。
4. WebSocket的协议比较轻量。

### 建立连接的过程
1. 客户端先是发起一个HTTP，包含`Upgrade: websocket`字节，
2. 服务器开始升级协议
3. 建立连接，以帧的形式传递数据。
4. 可以任意一方主动关闭连接
5. 通过心跳机制验证连接


行，我看完了。先说结论一句，你不是“什么都不会”，你是**知道一堆关键词，但还没把它们变成可以在面试里活着走出来的结构**。这在网工里很常见，也很危险。

我按你要求来，**先指出含糊和问题，再给建议，最后考你**。

---

## 一、先挑刺：你的笔记哪里“不合格”

我会比较狠，你忍一下。

### 1️⃣ 分层这块：背了，但没真的理解

你写了：

> 网络分为七层，但一般认为四层

问题不在对错，在**你没有立场**。

- 你没说明：
    
    - **谁在用七层？**（教学 / 理论 / OSI）
        
    - **谁在用四层？**（TCP/IP 实践模型）
        
- “方便控制”“变成小问题”这种理由，**像 PPT 模板**。
    

👉 面试官听到这段，只会想：

> “这人看过书，但没真正用过网络。”

**致命缺失**：  
你没有提到

- 接口边界
    
- 职责隔离
    
- 演进成本
    
- 局部失败不扩散
    

这些才是“分层”的工程价值。

---

### 2️⃣ 从 URL 到页面：流程正确，但层级混乱

你这段的问题不是“漏了细节”，而是：

> **所有东西混在同一抽屉里**

比如：

- DNS 是**应用层逻辑 + 网络层传输**
    
- TCP 三次握手是**传输层**
    
- HTTPS 握手是 **TLS，在 TCP 之上，HTTP 之下**
    
- 页面渲染已经是**浏览器引擎**，不是网络了
    

你现在的描述像是在说：

> “人吃饭 → 消化 → 细胞代谢 → 人活着”

对，但没法判断你是不是医生。

---

### 3️⃣ HTTP Header：你在“列单词”，不是在理解

`Accept / Encoding / Cookie / Authorization`

你没有回答任何一个关键问题：

- **谁发？什么时候发？**
    
- **影响什么行为？**
    
- **不带会发生什么？**
    

尤其是：

- `Accept` 和 `Content-Type` 的方向性
    
- `Cookie` 和 `Authorization` 的安全边界
    

👉 面试官最喜欢问的就是：  
**“这两个能不能互换？为什么不能？”**

你现在答不出来。

---

### 4️⃣ HTTP vs HTTPS：方向对，但逻辑有漏洞

你说：

> HTTPS = HTTP + SSL/TLS + 对称加密 + 非对称加密

这是**典型的“半懂型表述”**。

问题在于：

- **TLS 不是给 HTTP 用的，是给传输通道用的**
    
- HTTPS 的“版本”并不跟 HTTP/1.1、2、3 一一绑定
    
- HTTP/2 也可以跑在明文 TCP 上（h2c，虽然少见）
    

你后面自己也意识到问题了，这点我认可。

---

### 5️⃣ HTTP/2 队头阻塞表格：这是你目前写得最好的部分

这张表是少数**有工程意识**的内容。

但你漏了一个关键点：

- HTTP/2 的队头阻塞  
    **不是 HTTP 的问题，是 TCP 的可靠性语义带来的**
    

如果你能补上这一句，面试官会明显高看你。

---

### 6️⃣ Session / JWT：结构清楚，但安全意识偏弱

你写了流程，但没有写：

- **JWT 为什么不能随便放敏感信息**
    
- **JWT 撤销怎么做**
    
- **Session + Redis 如何解决多机一致性**
    
- **Cookie 的 HttpOnly / Secure / SameSite**
    

这会让人怀疑你**没在真实系统里踩过坑**。

---

### 7️⃣ WebSocket：理解偏“使用者视角”

你说它：

- 不需要总是验证
    
- 是长连接
    
- 很轻量
    

这些都对，但**还不够“工程”**。

你没有提：

- 为什么不能用 HTTP 长轮询替代
    
- 为什么 WebSocket 必须有 `Upgrade`
    
- 和 HTTP/2 server push 的根本区别
    
- WebSocket 本身不负责可靠性和重连语义
    

---

## 二、给你的改进建议（重点）

我不跟你说“多看书”这种废话。

### ✅ 1. 每个协议，你至少能回答三种问题

**对任何一个协议，你都要能说清：**

1. 它解决了什么“旧问题”
    
2. 它带来了什么“新问题”
    
3. 在什么场景下“不要用它”
    

比如 HTTP/2：

- 解决：并发效率、头部冗余
    
- 新问题：TCP 队头阻塞放大
    
- 不适合：高丢包、移动网络
    

---

### ✅ 2. 把“流程”按层拆开

你现在是：

> 一条时间线

你需要的是：

- DNS 流程（独立）
    
- TCP 生命周期（独立）
    
- TLS 握手（独立）
    
- HTTP 请求响应模型（独立）
    
- 浏览器渲染（剥离出去）
    

**面试官问哪层，你就抽哪层出来讲。**

---

### ✅ 3. 所有“对比”，必须落在“代价”上

不要再写：

> 更高级 / 更安全 / 更高效

请写：

- 多了几次 RTT
    
- 多了哪些状态
    
- 出错时更难 debug 在哪里
    

工程世界不信“更好”，只信“更贵”。

---

## 三、现在开始考你（认真回答）

我先给你 **基础 → 进阶 → 压力题**。

### 【基础题】

1. TCP 为什么一定要三次握手，两次不行的“确定性原因”是什么？
    
2. `Content-Type` 和 `Accept` 各自是谁的表达？如果冲突怎么办？
    
3. HTTP 是“无状态”的，这句话准确吗？为什么？
    

---

### 【进阶题】

4. 如果 HTTPS 已经加密了，为什么 Cookie 还要 `HttpOnly`？
    
5. HTTP/2 已经多路复用了，为什么浏览器还要限制并发连接数？
    
6. JWT 是无状态的，那“退出登录”是怎么实现的？
    

---

### 【压力题（面试官最爱）】

7. 如果一个 Web 页面在 HTTP/2 下加载反而变慢，你会从哪些角度排查？
    
8. QUIC 已经解决了 TCP 队头阻塞，那它为什么还没完全取代 TCP？
    
9. WebSocket 和 HTTP/2 的长连接，本质区别到底在哪？
    

---

你现在这个阶段，非常典型：  
**“信息密度已经够了，但解释密度还不够。”**

慢慢来，把“我知道”变成“我能解释”。  
回答题目，我继续当那个不太好惹的老师。

