真的是没办法了，请你扮演一个严格的老师，阅读一下我随手做的笔记，之后提供一些建议，接着，你再提出一些计算机网络相关的面试题。考一下我。

##  网络分层

网络分为七层，但是，七层分得太细了，一般我们可以认为分为四层。

- 网络接口层
  - 包括物理层
  - 数据链路层
- 网络层
  - 一般也就是负责IP寻址的这一块
- 传输层，
  - 也就是TCP/UDP这一层。
- 应用层，我们学习计算机网络的时候，也是按照这五层的顺序

## 为什么网络需要分层？

1. 分层方便我们控制，。
2. 分层之后，提供了灵活性和可替换性。
3. 分层之后，各层相互独立。
4. 分层之后，相当于把大问题变成了小问题。

## 从输入URL到页面展示到底发生了什么。

简单地说，一般都不简单。
1. 首先是浏览器发起请求，
2. DNS服务器解析域名，返回IP
3. 根据IP & 端口号 发起TCP请求
4. 三次握手，建立联系
5. 在联系的基础上再发起HTTPS/HTTP请求，
6. 服务器根据请求响应HTTP报文
7. 浏览器解析HTTP报文，再发起请求，得到需要的资源
8. 渲染页面
9. 可以按需关闭页面。

其实上面回答省略了很多步骤，就比如说，我们的请求究竟是如何在物理链路当中传递的，DNS是怎么解析的，TCP的三次请求是怎样建立的。

## HTTP Status Code
常见的主要是
2XX，成功
3XX 重定向
4XX 客户端错误
5XX 服务器内部错误

## Header
我这一次只是记录几个比较常见的吧。

1. Accept: text/plain
2. Accept-Charst: utf-8
3. Accept-Encoding: gzip
4. Authorization
5. Cookie

## HTTP vs HTTPS
1. 端口号不同
2. URL不同，很明显的http & https 
3. 安全性和资源消耗不同
  - 我们HTTP是非常简单的，运行在TCP上面，传输的是明文，无法验证对方的身份。
  - 但是HTTPS就不一样，它很高级，基于SSL/TLS之上的HTTP协议，经过加密，加密本身是普通的对称加密，但是密钥使用了服务器方的证书进行了非对称加密，所以，也显然，需要耗费更多的资源。
  - SEO优化，浏览器偏好HTTPS的网站

## HTTP/1.0 vs HTTP/1.1 

1. 连接方式
2. 状态码
3. 缓存机制
4. 带宽
5. Host头

## HTTP/1.1 vs HTTP/2.0

1. 多路复用，一次连接可以执行多次请求和响应，互不干扰，可以看做是HTTP/1.1的升级版
2. 二进制帧，HTTP/2.0 传输的内容是二进制帧，压缩更紧密，
3. 解决了头部阻塞，因为多路复用。
4. 头部压缩， HTTP/1.1 不支持`Header` 的压缩，所以很难受。但是我们的HTTP/2.0就支持了。
5. 服务器推送，服务器知道你请求了HTML肯定还需要CSS，于是打包送给你了。

## HTTP/2.0 vs HTTP/3.0

1. 传输协议发生了改变，HTTP/3.0基于QUIC
2. 连接建立的方式也不再一样。HTTP/3.0深刻可以不再需要握手。
3. 头部压缩的算法也变得不一样。
4. 连接迁移的方式也不一样，HTTP/3.0基于64位的ID，所以即使中途改变了网络环境，连接也可以不中断。
5. 头部阻塞，即使出现了丢包，也仅仅停下一个数据流，不会影响其他的数据流
6. 错误恢复，HTTP/3.0的错误恢复机制更加友好。
7. 安全性，HTTP/3.0的加密机制会把整个包包括报文头和报文体都进行加密，更安全。

| 方面 | HTTP/1.1队头阻塞 | HTTP/2.0队头阻塞 |
| --------------- | --------------- | --------------- |
| 层级 | 应用层(协议本身的限制) | 传输层(TCP协议的限制) |
| 根本原因 | 无法多路复用，并需要按照顺序传输 | 要求按照顺序交付，丢包就会阻塞 |
|受影响的范围|单个HTTP请求会阻塞后续所有请求|单个丢包会影响所有流|
|缓解方法|并行多个TCP连接|减少丢包|
|影响场景|所有情况，尤其是大文件传输的情况|丢包率较高的情况下|

## HTTP怎么保存用户状态


### Session & Cookie (主流方法)(())

1. 用户向服务器发送验证的信息
2. 服务器验证身份，建立一个Session，保存用户信息，生成用户的Session ID
3. 服务器返回Session ID，使用响应头的Set-Session字段
4. 浏览器保存字段
5. 当用户保持登录状态的时候，再继续登录，浏览器就会在Cookie当中携带这个字段
6. 浏览器解析字段，完成身份的校验

### 注意事项
- 客户端浏览器需要支持Cookie
- Session过期管理
- Session ID 的安全管理

Session的另外还有存储方式
- 服务器内存：简单，快速，但是不能持久化，而且无法处理多服务器的问题。
- 数据库，读写性能很低
- 分布式缓存，主流方案。

### 重写URL
当Cookie无法使用的时候，我们就直接把Session ID 写在 URL 当中，但是这样的危害太大。安全性很差。

### Token-based (eg JWT-JSON Web Token)

- 特点，无状态
- 用户向服务器发送验证的信息
- 服务器解析信息，成功就返回已经签名的JWT
- 用户保存JWT
- 用户再访问的时候，就携带JWT
- 因为JWT里面已经有了很多信息，所以就不需要在服务器这一端保存其他的信息。

参考这个知乎的回答，里面提到了一些关于HTTP的GET & POST的差异。https://www.zhihu.com/question/28586791

还是很多启发的，就比如说，我们伟大的Elasticsearch，使用的就是「GET」，但是照样可以传递非常复杂的语义。因为语义太复杂，所以我们使用JSON

## WebSocket

### ✅内涵
我们可爱的Websocket的内涵是什么？
我认为，WebSocket不需要什么内涵。
说起来，这个东西还是我入门Web的开端，我一开始就是写Python Django，那时候就使用了这个协议。


