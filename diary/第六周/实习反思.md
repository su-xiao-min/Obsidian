# 总结

留一点东西给leader吧。
感谢你这段时间分发的任务和宽容，
我完成得确实很糟糕，

方方面面。
来公司了半个月，
完成了四个任务，
或者并没有，
还要返修……

## 第一个任务

第一个任务，OPPO消息推送的
我之后完成第四个任务的时候，
重新测试了，
这一次我就拿不到regId了，
我测试了好半天，
但是那个回调函数就是没有被触发。
很抱歉，
好像又失败了。

## 第二个任务，

其实也就是我第一个提交的任务，因为第一个任务在等OPPO的channel
因为提交得着急，
所以文书也没有撰写，
因为前端跑不通，
检查了一下逻辑，
就提交了。
因为那时候确实还是很畏惧前端的。

为什么要卡在这里？
算了，
也不重要了。

## 第三个任务，

也就是写前端消息合并的逻辑
直到这时候才开始好好整理前端的逻辑
直到这时候，
才开始好好学习React，
完成第一个任务的时候，
我把自己死死限制在kotlin代码的部分

那时候虽然看到了React的App部分，
不想看，
前端好长……

真正开始看，
还是很头晕，
一方面是代码头晕，
另外一方面，
运行时候的依赖总是报错，

前端是版本不对，
导致接口出错，

后端则是数据库不完成，
导致很多东西根本就无法运行。

是啊，
就好像您说的，
这样的问题，
直接询问您，
直接拿到最新的数据，
与其他人一致的依赖
那么就没有问题了。

哎，
第一天拷项目的时候，
为什么不是直接拷贝源文件呢？
还要自己git clone……
因为那时候确实没有经验啊。

## 第四个任务

好像没有怎么写，
很简单一个功能，
要求也很简单，
一个小时的任务，
我又浪费了两天。

我在干嘛呢？
首先，
我先是学习前端React相关的内容
我要看一下前端是怎么呈现的，

然后我就开始学习React的各种各样的Hook了，
因为我的Eslint一直在告诉我，
这个useEffect用得有问题，
什么问题？
「当时没有写，
简单地说，
应该至少把useEffect注册的函数当中所有的变量都添加到最后的依赖项当中，
这样就避免了说，
闭包的问题。
但是，
同时也会出现新的问题，
所以就需要使用useCallback来封装，
useEffect很可能多次触发，
在测试的环境下，
一开始就会触发两次，
所以一定要保证这个函数的幂等性
感觉我现在的水平，
还走不了前端」

反正经过了之前几天，
大概整个人已经彻底不着急了，
反正着急也做不出来，
还不如慢慢学。

学完React的Hook，
也加深了对于React渲染逻辑的理解，
感觉我们的项目确实有一点，「乱」
有一点「烦」。

之后，
就是推送消息的实现。

当然，轮询就可以了。
但是，
我学习了那么久，
说轮询是很不可取的行为，

我们的项目也不能回调，
看了一下，
有websocket，
那么就用这个吧。
我得学习一下我们项目是怎么使用它的。

感觉用得有一点乱，
几乎没有可维护性。

可以用了，
差不多学会了。
但是，
什么场景下后端推送呢？
当然是count修改的场景，
但是，
好多场景啊，
一个一个写？
我要监听一下。
报错了。
因为事务……
没有想到有一天我会被事务报应。
简单地说，
插入和推送在一个事务当中，
所以，
推送的时候还没有flush持久化，
所以就存在问题。

其他的方法也好麻烦，
毕竟好多个方法。

「怎么这么久还没有写完呢？」

完蛋，
好了，
轮询大法好，
先提交再说呗。
不过测试第四个任务的时候
也失败了
因为第一个任务失败了，
不对，
和第一个任务没有关系，
因为OPPO手机不支持角标。
但是我也不知道为什么第一个任务就不成功。

## 数据库

也是这几天在做的事情。
可能我不该为自己的迟缓辩解，
方方面面都在拖延，
各种各样的事情都让让我头大。
但是，
我看着项目的代码，
有一种强烈的渴望，
希望能够重构。
就好像说，
我们项目当中的参数校验，
我也希望能够使用Jakarta Validation，
让它和业务逻辑解耦。
看到数据库表，
好多，
前面每一次的任务都有数据库的字段不完成的情况。
我也很希望重构一下，
重构的时候，
也是让自己好好梳理整个项目的数据结构。
但是，
我感觉，
我们开发这个项目，
貌似确实缺乏一个单独专门的DBA，
所以SQL写得很乱。

### 外键

我想建立外键。
为什么我在想这件事呢？
因为我真的在一张表一张表地读，
找一下到底alter.sql当中哪些句子没有写进其他的SQL当中，
我希望一劳永逸解决这个问题。
解决的过程中，
当然是，发现了更多的问题。
不必要的关联表，
我没有检查过，反正有一些表看上去确实多余。
还有就是，
要不要建外键。
我记得您说过不要建立外键，
一切在应用层面解决的。
我也知道，
您的考量。

我要怎么论述它的合理性呢？

**首先**是，
这样，
我使用DataGrip在表之间移动的时候就更方便了。
「这理由好像很薄弱」
而且，
这样让后面看数据库的人也会轻松一些，
各种表之间的逻辑也很清晰，
导出成uml也非常方便

**之后**，
这样也符合关系型数据的原则，
让数据库帮我们保持数据的一致性，
就好像说MD5作为所有文件的外键，
这样就保证，
只要文件可以插入，
它一定存在MD5的origin file，
即使我们的业务逻辑出现错误了，
我们也可以在Insert的时候就立刻发现。

当然，
业务逻辑层面校验也可以，
但是，
总要多一点保险吧。
就好像参数校验，
前端校验了，
后端也要校验。
数据库保证数据的最终一致性。

---

至于说反对意见，
我当然也在看啊，
我也是背八股出来的，
所以数据库不应该建立外键，不应该使用存储过程，
这些东西我都知道。

但是，问题是，
外键不应该建立，也是有自己的使用前提的吧。
首先，说外键影响性能，
那么问题是，我们Java自己进行参数校验，
要格外查询，
也在影响性能啊。
而且，也如您说的，
我们的项目很小，不在乎这一点性能。
「如果在乎，大可以换成PostgreSQL」

其次，
在分布式系统下，
关系型数据库的ACID确实难以保证，
所以要使用兜底机制来实现最终一致性。
但是，我们也不是分布式事务啊，
ERP当中使用外键就很合适，
没有高并发，
没有分布式，
使用外键就相当于加了一个简单的保险，
而且让接受项目的人也可以更轻松一些。

### PostgreSQL

至于说，
为什么提议换成PostgreSQL，
额，其实也没有什么特别的原因，
就是因为我看到的炮轰MySQL的视频，
再加上我看到的吹捧PostgreSQL的视频。

> [千疮百孔的世界上最流行的数据库【让编程再次伟大#番外1】\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1BAABeKEqp?spm_id_from=333.788.videopod.sections&vd_source=c7ebf7408123ab5de1032a62a32045bd)
>
> 里面提到一些MySQL的bug，就比如说，它的trigger会很莫名其妙。有时候无法出发
> 还有，就是它的enum枚举的排序逻辑诡异。
> 还有一些index的副作用。
> MySQL可能不会自己去选择最好的index，
> 等一下，
> 这个bug后来不是被修复了吗？
>
> [有些数据库是蠢，有些是坏，它是又蠢又坏【让编程再次伟大#番外2】\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1M1Koz6EW1?spm_id_from=333.788.videopod.sections&vd_source=c7ebf7408123ab5de1032a62a32045bd)
>
> 另外，还要foreign key，
> 修改foreign key的时候，会锁表。
> 但是，MySQL可能会格外上锁，在index的时候。
>
> 另外，
> MySQL的事务无法让DDL回滚，
> 只能让DML回滚。
>
> MySQL还是比较逆天的。
> MySQL又蠢又坏。
>
> [全网最尊重MySQL的博主\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV12We7z8EZR?spm_id_from=333.788.videopod.sections&vd_source=c7ebf7408123ab5de1032a62a32045bd)
>
> 我感觉，
> 要是年后有机会的话，
> 就去迁移一下吧。

实际上，
诚如你提到的，
没必要。
哪怕PostgreSQL方方面都好过MySQL，
但是，
对于一个已经运行起来的项目，
何必自找麻烦呢？
刚学习《数据库原理》的我，
一直没有理解，
为什么人大金仓要花那么大的篇幅介绍各种数据库如何迁移，
反正能用就行了。
MySQL的bug，
我们不会遇上。
MySQL的性能，
我们也不会在意。
「不在意的话，建外键吧」

#### BucketName

为什么要关心这个问题，
因为我想给那堆file相关的表建立外键。
我的想法当然是，使用MD5
「说起来，我还真的花了一个下午去学习MD5相关的内容诶」
但是，origin file使用的是联合唯一索引，融合了BucketName & MD5

> 你刚才提到外键必须要唯一，
> 我现在有一个问题，我数据库表当中存着一个MD5数据，但是我看他的建表语句当中，
> 它和buckname合起来构成一个唯一索引，
> 然而，
> 我看这个buckname的，它是MinIO的配置，在生成环境和开发环境是不一样的，
> 所以，我感觉生成环境下，
> 可以使用MD5作为唯一索引，
> 为什么MinIO需要buckname啊
> 是否后面会出现确实需要联合唯一索引的情况呢？
> 我能不能修改呢？
>
> ---
>
> 不是……
> 我现在也觉得很诡异，
> 实际上，
> 我们的开发环境下根本就没有数据，
> 我们开发环境的数据库也是本地的测试数据库，
> 所以，
> 根本就不会和线上的数据库碰撞，
> 上线的时候，
> 我们也会自己去更换一个buckname。
>
> 更重要的是，
> 我们的数据库表当中，
> 和origin file关联的文件表当中，根本就没有buckname这个字段……
> 效果就是，
>
> 我们线上删除文件，
> 只会删除配置当中写的那个buckname里面的文件。
> 快点评一下，
> 这样设计的用意到底是什么？
> 难道，
> 我应该也给我们的文件关联的表添加一个buckname？

我也不知道这个问题的解决方法，
我看了一下前端的逻辑，
貌似一共就只有两个BucketName，一个是`feedback-detail.tsx`的`const Upload_BUCKET_NAME = "tndas";`，另外一个就是默认的`tnlib`，和后端默认的值是一致的。
我当然理解拆分bucket的好处，
因为不同的bucket可以实现完全不同的权限管理和运行逻辑，
但是，
MinIO这一块也是我知识的盲点，
并不懂。
我也没有理解，
在我们项目当中分BucketName的用意。
如果不区分，
那么BucketName完全可以做到对于前端透明，
后端写进MinIOUtils的内部，
就不需要处处传递和校验了。
数据库里面也不需要多存一个字段。

如果要区分，
那么干脆就使用联合唯一索引，
之后在每一张关联的表上面，同时使用`bucket_name` & `md5` 两个字段作为外键，
对于那些特定场景下使用的只会存在一个bucket当中的内容，
直接给一个default的值就可以了。

如果不使用外键，
把MySQL当成KV，那么也没有这种问题了。
谁叫我想要建外键呢？
也是一种想要解耦合的倾向吧。

另外，
谈一下我刚才说的那个bug吧，
如果我们使用MD5去重，
那么我们怎么解决不同的bucket当中存储同一个MD5呢。

后端的逻辑是

```java
@RequestMapping(value = "/files/exists/{md5}", method = RequestMethod.GET)
public StdResult<OriginFile> checkFileExists(
        @PathVariable String md5,
        @RequestParam(required = false) String bucketName) {
    OriginFile res = fileService.checkFileExistsByMD5(md5, bucketName);
    return new StdResult<>(StdStatus.STATUS_200, res);
}
```

看起来也没有什么问题，校验是否存在的时候，
同时考虑了BucketName 和 MD5，
我看了一下，
确实没有什么问题，
直接自己在业务层面限定了，
其实也就是，在业务层面限制了这个表的buckname为tnlib。

感觉，
还有一个优化的策略，
就是我们每个BucketName的存储的origin file都单独建立一个表。
当然，如果不是那么在意通过数据库层面实现ACID，
同时自信后续接受项目的人能够对于项目当中存在的数据依赖都非常熟悉，
把MySQL当成KY也不错。

## 文档

感觉我们公司的文档比较缺乏，
可以用Markdown写啊，
也挺好看的，
用Typora还可以代码高亮渲染，
颜值真的很不错了。
不要再使用Word了……
好吧，
好像只有我，
文档写得比代码还多。

自打使用上Markdown之后，
我就很讨厌Word了，
刚才试着调整了一下格式，
还是很讨厌Word，
复制粘贴都不方便，
把文本从Markdown当中复制到Word里面，
全乱了。

算了，
反正最后的任务，
也因为自己的账号被注销，
无法提交了，
提到PDF无法修改，
那我把Markdown一块发过去吧。

## 学习

如果有下一个十二天的话，
我一定要做得比这个十二天好一些，
我知道前端是不可以信任的，
我知道后端是不可以信任的，
我知道数据库也是不可以信任的，
我知道npm install 的东西也是不可以信任的。
我知道本地复现会出现很多线上不会有的问题，
我知道很多bug不需要去解决。

不过，
看着学长行云流水操作定位问题，
实在是有一些自惭形秽，

我遇到的问题，
都不是太难的问题，
因为我自己的迟缓，
所以无法快速定位问题，
所以无法解决。

慢慢学习吧。
看来我还需要再沉淀一波。

## 结论

蛮希望给下一个接手这个项目的人留下来一些东西的，
不过，
很可惜，
也没有留下什么，
想做的事情都没有做出来，
也没有机会做了。

留下一些说明文档，
留下一些开发的注意事项，
留下我踩坑的记录，
好像只能这样了。

如果再重来十天，
可以做得更好一点吗？
那当然了，
一定不要在不必要的事情上面浪费时间。

那些自己已经checkout出来，
但是还没有merge的分支，
大概也没有什么存在的价值了，
是啊，
如果早一点做好离职的准备，
大概最后的几天还能够轻松一点。

算了，
教训也已经在其他的地方写下了。

最后轻微吐槽一下吧，
周老师你布置任务一点都不清晰……
当然，可能也是我自己太废物了吧。
什么都不会，
就来公司了，
所以，
第二天早上开发安卓的任务，
您来到我面前说了好多话，
我真的没有太听懂，
后来也走了好多坑。

也是我自己好笑吧，
您布置下来任务，
我都不知道应该动哪个文件，
乃至不知道应该动前端还是动后端，
或者两个一块动，
我总有自己的预设，
高低应该自己先跑一下，
看一下问题。

应该自己把项目熟悉一下，
标记一下重要的相关的文件。
「所以后来我学会了书签的功能！
IDEA挺好用的，
DataGrip也挺好用的，
这电脑从来不是因为IDE卡顿，
而是因为前端项目和App热加载卡顿」

如果是我的话，
我就会写下来，
相关的文件是什么，
接口说明是什么，
哪里应该怎么走，
有什么注意事项，
遇到问题了应该怎么办，

可能在您看来这些都是我应该会的，
很可惜，
我不会。

我走错了好多路，
希望下一个人聪明一点吧。
希望你聪明和幸运。
项目依赖问题和数据库问题不要想着靠自己解决，
需求不清楚也要直接去提问，
早一点麻烦leader，
会比任务拖着无法完成强太多了。

ERP如果不会使用，
也早一点去提问吧。

## 其他反思

上面的就是发给leader的版本，
之后我重读，
希望还能够留下来一点教训。

其实上面读完之后，
感觉有一点尴尬，
关于四个任务的总结未免琐碎和无趣，
也是重复，
因为在其他文档当中写下了，
然而这里的重复并没有言简意赅，
也并不存在格外的深刻。

我认为，
我还是应该现实主义一点，
在我拿到继续实习的资格之前，
我就应该尽可能快速完成任务，
其他的事情都不那么重要。
像是什么SQL啊，像是什么版本问题了，
这些都不是很严重，
但是这些都是琐碎然而我解决起来会很费功夫的，
果断分析出来问题的原因，
并且使用最高效的方式解决问题
「leader，这里我需要你的帮助！」
才是正确而明智的决定。

不要做全栈了，
要去大公司，
这也是我自己下定的决心。
另外早一点阅读一些好书，
继续准备八股吧。

当然，
我也可以思考一下，
我应该怎么完善自己的简历了。
