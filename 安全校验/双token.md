毕竟写进简历了，
还是看一下吧，
我感觉，可以从凤凰架构开始。

虽然我也没有想到，这个东西我看了一天。

[JWT双令牌认证实现无感Token自动续约-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2446904)

我也自己总结一下，

JWT也就是一种签名算法。核心保证无法被篡改，换言之，只有服务器可以签名。

如果是单节点的服务器，那么使用对称密钥就可以了，多节点，可以使用非对称秘钥，一个签名的服务器持有私钥，剩下的服务器持有公钥。

用户通过客户端访问服务器，服务器返回JWT。里面包含非重要的信息。一般也就是用户id，再加上过期时间，只要证明用户确实Access就可以。因为JWT不是加密，只是签名。当然也有一点转码，不过使用的是base64。

之后用户再访问服务端的时候，携带JWT就可以了。它一般放在Header当中。

一般JWT作为无状态的存在。如果强行使用Redis记录JWT，那么我感觉不如使用Cookie+Session。



JWT+双token，

Access token和前面一样，但是可以缩短有效时间

Refresh token则保存在Redis当中，长一些时间，效果是，可以撤销。

其实这里既然都要存在Redis当中了，不使用JWT也完全没关系，直接使用SessionId也差不多。
但是继续使用JWT可以方便保持和前面一样，只不过在Access token过期的时候直接更换token。

使用Refresh token在Access token过期之后 调用Refresh的接口，得到新的Access token & Refresh token，也就实现了用户无感刷新。

使用Refresh token还可以解决一些更复杂的事情，就比如说，一个地方登录之后，强制另外一个地方下线只要Refresh token关联的Redis记录当中再多一些字段就可以了。

点评一下我理解的不足的地方。提出一些这种设计的缺陷。再提出一些系统设计的思考题。



后端开发怎么这么困难呢……………………

──────✦──────

不会一点。

# ChatGPT

你这段理解整体是**及格偏上**的。逻辑顺序没乱，核心概念也没跑偏。
但有几个地方你理解得有点“像懂了，其实还差一刀”。我给你拆一下。🔪

------

# 一、你理解中不够精确的地方

## 1️⃣ “JWT就是一种签名算法”

不对。

- JWT = 一种**Token格式规范**
- JWS = 用于签名
- JWE = 用于加密

JWT可以：

- 只签名（最常见）
- 只加密
- 又签名又加密

你说“JWT不是加密，只是签名”是经验结论，不是定义。

这在系统设计里是危险的。
你不能把“常见用法”当成“概念本身”。

------

## 2️⃣ “多节点就必须非对称密钥”

不必须。

多节点场景有三种方案：

| 方案                     | 是否需要非对称 |
| ------------------------ | -------------- |
| 所有节点共享一个对称密钥 | 不需要         |
| 使用配置中心下发密钥     | 不需要         |
| 专门签发服务+公钥校验    | 需要           |

非对称的优势是：

- 私钥只在签发方
- 校验方泄露也不影响签发能力

但不是“多节点必须用非对称”。

你这个表述偏工程经验，不够严谨。

------

## 3️⃣ “JWT是无状态的”

这是个经典误区。

JWT本身确实可以做到无状态校验，但：

- 一旦你需要强制下线
- 一旦你需要权限变更实时生效
- 一旦你需要撤销

你就会重新引入状态。

所以：

> JWT是“理论无状态”，实际业务通常是“弱状态”。

真正完全无状态的系统，在企业系统里基本不存在。

------

## 4️⃣ “既然用了Redis，不如Session”

这是你现在理解里最值得深挖的地方。

你现在的逻辑是：

> 都用Redis了，还JWT干嘛？

这个问题很好，但你忽略了一件事：

**Access token仍然是自验证的。**

差异在于：

| 项目            | Session | JWT + Refresh      |
| --------------- | ------- | ------------------ |
| 每次请求查Redis | 是      | 否（只在刷新时查） |
| 扩容压力        | 高      | 低                 |
| 网关校验        | 不方便  | 非常方便           |
| 微服务间传递    | 麻烦    | 非常自然           |

JWT+Refresh的核心价值：

> 把“高频校验”变成无状态
> 把“低频控制”放到有状态层

这是架构上的分层思想。

------

# 二、这种设计的缺陷

别太浪漫。JWT不是银弹。

## 1️⃣ 无法即时撤销Access Token

只要Access token没过期：

- 它就是合法的
- 你无法阻止

这意味着：

- 如果被窃取
- 你只能等它过期

缩短有效期是折中，不是解决。

------

## 2️⃣ Token体积问题

JWT体积远大于SessionId。

- 每次请求都携带
- Header膨胀
- 在移动端是负担

在高QPS场景会变成网络成本。

------

## 3️⃣ 权限变更延迟问题

如果用户角色发生变化：

- 老的Access token里权限还在
- 在过期之前不会更新

这在B端系统里可能是灾难。

------

## 4️⃣ Refresh Token被盗更危险

Access token短期有效。
Refresh token长期有效。

如果Refresh被窃取：

- 攻击者可以持续刷新
- 形成“永久登录”

所以Refresh token必须：

- 绑定设备
- 绑定IP
- 设置rotation（每次刷新更新）

否则只是换个死法。

------

## 5️⃣ 双Token复杂度显著上升

你引入：

- 刷新接口
- 失效机制
- 黑名单机制
- 并发刷新控制
- 重放攻击防御

复杂度远高于Session。

很多团队过度工程化。

------

# 三、真正值得思考的架构问题

现在进入有价值的部分。

## 思考题 1️⃣

如果你是一个API网关团队，
为什么你更偏向JWT，而不是Session？

提示：跨语言、跨服务。

------

## 思考题 2️⃣

如果用户权限发生变化，你如何让JWT立即失效？

可选思路：

- 版本号机制
- 黑名单
- Token绑定权限版本

你选哪种？为什么？

------

## 思考题 3️⃣

如何防止Refresh Token重放攻击？

提示关键词：

- Token Rotation
- jti
- 一次性刷新

------

## 思考题 4️⃣

如果是移动端App + Web + 小程序多端登录，
你如何设计：

- 单点登录
- 单设备登录
- 强制踢人
- 多设备共存

只用JWT你做不到。

------

## 思考题 5️⃣

在什么场景下你会彻底放弃JWT？

比如：

- 内网系统
- 强一致权限系统
- 银行交易系统

为什么？

------

# 四、你现在的水平判断

你已经理解：

- JWT签名本质
- 双Token机制
- 无状态优点
- Redis控制撤销

说明你不是在背八股。

但你现在的思维仍然偏：

> 技术对比层

还没上升到：

> 架构权衡层

真正的高级思考不是：

“哪个好”

而是：

> 在什么约束下选哪个。

------

最后一句冷静提醒 🧊

JWT流行，不代表它高级。
Session老，不代表它落后。

架构的核心不是“新”，
是**可控复杂度**。

你已经走在正确方向上，只是还差一点抽象能力。继续推。
