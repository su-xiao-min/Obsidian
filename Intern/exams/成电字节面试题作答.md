我正在准备字节跳动的面试，麻烦你帮我改一下试卷，
尽可能严厉一些，
看一下我存在的不足。

1、redis宕机时的容灾能力

If the fail is on the Master,
then one of the slaves will be selected as the master;
else:
it doesn't matter,
but you'd better set a new slave quicky,
in case the reading won't be block;

2、redis的master节点下线了，怎么重新选取主节点？
可以让 System Manager selects one of the slave
Or you can set a sentinel

Redis Sentinel is a 分布式（不会英语） Structure, to imply the Failover;

1. Monitoring
2. Automatic Failover
3. select the new Master
4. Notification

When the master is unable to use, the Sentinel will begin the process of vote;
If more than half of the sentinels consider the master quorum,
then a slave will be selected as the new master
and other slaves will copy from it
then the sentinel will notify the clients to connect the new master

3、领导哨兵节点怎么从从节点中选择出主节点
随机吧，这个还真的不知道。
4、bloom过滤器的优缺点？
优点：效率很高，内存占用也不大，
缺点：
可能误判，
但是，
可能误判这一点其实也不太影响，
有一些地方不在乎，就比如说我们的数据库的缓存击穿的时候，不在乎一两个漏网之鱼
有一些地方，再格外加一层校验就可以了。

5、他的误判是假阳还是假阴？
捋一下，假阴
简单地说，
就是根据几种哈希算法，
如果你存在，对应的位 | 1，
反过来说，判断你存在，那么几种哈希算法，你的位置都应该是1，
只要不是，你必然不在，
但是即使都是，你也可以不在。

6、缓存雪崩怎么解决

1. 大量数据一块过期，
2. 解决的话，首先就需要分开设计过期时间，
3. 可以弄一点随机性
4. 然后，一般只要不是集中过期，就没有什么问题
5. 还有问题的话，
6. 我记得一个有趣的bug，
7. 一个服务器上线海外，一直出现故障
8. 原因是，这个服务器有一段时间需要备份，性能就会下降
9. 之前都是弄在晚上，
10. 然后就到 海外了。

7、redis为什么要设计成单线程

1.  性能高，就没有切换的负担了，
2.  基于内存操作，效率也很快
3.  而且，感觉就Redis的使用场景，多线程完全没有必要
4.  多进程倒是有一点点必要

8、分布式锁怎么延长过期时间？

1. 当然是选择成熟的中间件
2. 让他自己续期
   9、缓存和数据库等数据一致性，集群模式下缓存无法成功删除，缓存未成功删除时
   有哪些策略
   不知道。

11、热key问题怎么解决

1. 先识别，
2. 能够让Redis也宕机的热key实在是太恐怖了！
3. 可以让Redis分片，
4. 可以分布到不同的服务器
5. 可以使用二级缓存
   诶，问题是，同一个key怎么分散到不同的服务器上面呢？

Redis是怎么解决过期数据的？
使用了惰性过期和定时过期两种策略。
实际上，你使用定时过期就必然包括惰性过期……
太有趣的做法了。
它还有好多种内存淘汰策略，

12、分布式系统下，你觉得互斥锁有什么优缺点
优点`٩(◕‿◕)۶`

1. 安全
   缺点`(T_T)`
2. 成本
3. 性能
4. 而且，还是那一点，它无法从根本上解决分布式系统存在的问题

13、mysql一张表最多的存储数据数
不知道，

14、mysql索引B+树的常用层数是？
也不知道，我估计两层就差不多够了吧，B+树不是主打一个低层，减少I/O吗？

15、B树和B+树的区别
这个知道，
B+数所有数据都存在叶子结点上面，而且有指向下一个叶子结点的指针，
总之就非常适合数据库的索引，
16、threadlocal的底层实现
就是一个大Map，整个JVM拥有一个大Map，key是每一个线程自己，值是一个小Map，小Map的key是你创建出来的这个ThreadLocal对象本身。

17、线程池的底层实现
不知道，不就是一个被统一管理起来的很多线程组吗？
然后统一接受任务，统一处理，按照不同的策略。
18、jvm的垃圾回收机制了解吗
这个了解，方式还挺多的，
不太记得了。
19、具体讲一下G1
不记得了。
20、Ai coding和ai带给你学习上的改变
21、设计一个抖音短视频点赞系统，支持百万级并发点赞，要保证实时性和一致性，你能讲一下你的设计思路吗
肯定要使用分布式啊，
然后基于我们的CAP理论，
所以，这里的一致性就要放弃一下，而且，你说点赞吧，都几百万并发点赞了，我感觉，差一两个其实也没有影响，当然，为了严谨性，我们还是不要这么搞
「虽然刷好评这种行为让点赞的数据本来就不准确」
所以，我们完全可以采取最终一致性的做法，优先保证可用性。
点赞数据肯定要临时从Redis当中获取，
分布式的Redis，定期去同步就可以了，实时性，其实只要满足，单个用户点赞的结果自己立刻可见就行了。

麻烦你点评的时候，再附带一些补充问题，针对我只是的薄弱点。

## DeepSeek

同学你好，收到你的“试卷”。我会以字节跳动技术面试官的视角，对你的回答进行逐一点评和修正，态度会 **非常严厉** 和 **直接**，目的是让你看到真实面试中可能暴露的问题，并帮助你改进。

你的回答展现了对一些概念有基础的了解，但存在 **致命问题**：**深度严重不足、表达极不严谨、关键知识缺失**。这会让面试官认为你的知识是“道听途说”和“浮于表面”的。

---

### **逐题严厉点评与修正**

**1、redis宕机时的容灾能力**

> **你的回答**：语法和逻辑混乱，像在说口语。“it doesn‘t matter”、“you‘d better” 这类表达非常不专业。对“从节点下线”的影响判断过于轻率。
> **面试官可能评价**：此人对Redis高可用的理解非常初级，且沟通表达能力有待加强。

**修正与补充**：

- **主节点宕机**：如果部署了 **Redis Sentinel（哨兵）** 或 **Redis Cluster（集群）**，会自动触发**故障转移**，选举一个从节点提升为新主节点，客户端会被重定向到新主节点。
- **从节点宕机**：这很重要！如果是从节点宕机：
  1. **影响读扩展能力**：减少了读请求的分担者。
  2. **影响可靠性**：主节点的数据副本数减少，数据丢失风险增加。
  3. **需要尽快恢复**：**必须尽快**手动或通过运维平台补充新的从节点，以恢复系统的冗余度和读性能。这不是“you‘d better”，而是“must”。

**2、redis的master节点下线了，怎么重新选取主节点？**

> **你的回答**：提到了哨兵，但描述不精确。“分布式（不会英语）”暴露了准备不充分。“vote”、“quorum”用得对，但过程描述不清晰。
> **面试官可能评价**：知道有哨兵机制，但对其工作原理一知半解。

**修正与补充**：
是的，由 **Redis Sentinel** 负责。流程严谨描述如下：

1. **主观下线**：某个哨兵发现主节点无响应，将其标记为“主观下线”。
2. **客观下线**：该哨兵询问集群中其他哨兵。当超过配置的**法定人数**的哨兵都认为主节点不可达时，则将其标记为“客观下线”。
3. **选举领导者哨兵**：所有哨兵会通过 **Raft算法** 选举出一个**领导者哨兵**，由它来执行故障转移。
4. **选举新主节点**：领导者哨兵根据规则（见下题）从从节点中筛选并选举出新主节点。
5. **故障转移**：让新主节点执行 `slaveof no one`，并让其他从节点复制它。最后，通知所有客户端新主节点的地址。

**3、领导哨兵节点怎么从从节点中选择出主节点**

> **你的回答**：“随机吧，这个还真的不知道。” —— **这是本试卷最扣分的回答之一！** 直接承认不知道核心算法，面试很可能到此结束。
> **面试官可能评价**：缺乏求知欲和基本的准备。这是哨兵机制的核心考点。

**修正与补充**：
**绝对不是随机！** 选举基于一套明确的规则，按优先级筛选：

1. **过滤不健康的节点**：网络连接不稳定、长时间无响应的从节点被排除。
2. **优先级**：比较 `slave-priority` 配置值（越小优先级越高）。
3. **复制偏移量**：选择**复制数据最完整**（复制偏移量最大）的从节点。
4. **Run ID**：如果以上都相同，选择 **Run ID**（启动时生成）字典序最小的从节点。

**4、bloom过滤器的优缺点？**

> **你的回答**：优缺点基本点到了，但“不在乎一两个漏网之鱼”这种表述非常不严谨。
> **面试官可能评价**：对布隆过滤器的应用场景理解模糊。

**修正与补充**：

- **优点**：空间效率极高，插入和查询时间都是常数O(k)。
- **缺点**：
  1. **存在误判率**（假阳性）：判断某个元素存在时，可能实际不存在。
  2. **不支持删除**：传统的布隆过滤器无法删除元素（Counting Bloom Filter可以支持）。
- **应用场景**：
  - **缓存穿透**：**非常在乎“漏网之鱼”**！我们的目的就是**绝对阻止**不存在的key击穿到数据库。布隆过滤器说“不存在”就一定不存在，这完美解决了问题。说“存在”的误判，只是让它去查一下缓存（结果为空）或数据库（结果为空），并不会造成数据库压力激增，这正是我们想要的。
  - **爬虫URL去重**、**安全领域黑名单**等。

**5、他的误判是假阳还是假阴？**

> **你的回答**：逻辑推导正确，但结论“假阴”完全错误。这说明对“假阳/假阴”的定义不清。
> **面试官可能评价**：概念混淆，基础不牢。

**修正与补充**：

- **假阳性（False Positive）**：**实际不存在，但判断为存在**。布隆过滤器会发生这种情况。
- **假阴性（False Negative）**：**实际存在，但判断为不存在**。布隆过滤器**绝不会**发生这种情况。
- **所以是：假阳性**。你的推导过程描述的现象就是假阳性。

**6、缓存雪崩怎么解决**

> **你的回答**：解决方案（设置随机过期时间）正确，但后面的“故事”不知所云，与问题无关，显得思维发散、不专注。
> **面试官可能评价**：能说出常见方案，但表达缺乏条理，喜欢跑题。

**修正与补充**：

- **原因**：大量缓存数据**在同一时间**过期失效，导致所有请求涌向数据库。
- **解决方案**：
  1. **差异化过期时间**：给缓存设置过期时间时，增加一个随机值（例如：基础时间 + 随机1-5分钟）。
  2. **热点数据永不过期**：对极热数据，设置逻辑过期（后台异步更新）。
  3. **服务降级与熔断**：当数据库压力过大时，对非核心业务直接返回降级内容（如默认值、错误页）。
  4. **构建高可用缓存集群**：如Redis Cluster，避免单点宕机导致全局雪崩。
  - _你提到的“海外服务器备份”案例，更像是**运营事故**或**资源争用**问题，与经典的“缓存雪崩”不是一回事。_

**7、redis为什么要设计成单线程**

> **你的回答**：“多进程倒是有一点点必要”——完全错误且危险的观点。Redis就是单进程、单线程处理命令。
> **面试官可能评价**：对Redis核心架构理解有根本性错误。

**修正与补充**：
核心原因：**避免多线程的上下文切换和竞争条件，实现简单高效的内存操作。**

1. **纯内存操作**：CPU不是瓶颈，内存速度和网络I/O才是。
2. **避免锁开销**：单线程天然避免了多线程的锁竞争，数据结构操作无需加锁。
3. **高性能IO模型**：使用 **I/O多路复用**（如epoll）处理海量连接，非阻塞IO使得单线程能高效处理并发请求。
4. **注意**：Redis 6.0 引入了**多线程IO**，但**仅用于处理网络数据的读写和解析**，核心的命令执行模块依然是单线程的。这与你说的“多进程”无关。

**8、分布式锁怎么延长过期时间？**

> **你的回答**：“选择成熟的中间件”是正确但取巧的说法。面试官想听的是原理。
> **面试官可能评价**：有实践经验但缺乏原理性思考。

**修正与补充**：
成熟分布式锁（如Redisson）的**看门狗（Watchdog）机制**：

1. 客户端A获取锁成功，会启动一个**守护线程**（看门狗）。
2. 守护线程定时（比如在锁过期时间的1/3时）去检查客户端A是否还持有锁（通过TTL判断）。
3. 如果还持有，则**刷新锁的过期时间**（执行 `PEXPIRE` 命令）。
4. 当客户端A释放锁或异常宕机时，守护线程停止，锁最终会因过期而释放，避免死锁。

**9、缓存和数据库等数据一致性...**

> **你的回答**：“不知道。” —— **又一个致命回答**。这是后端面试最高频的问题之一。
> **面试官可能评价**：对系统设计中的核心挑战缺乏思考。

**修正与补充**：
这是一个经典难题，没有银弹，只有权衡。常见策略：

1. **Cache Aside（旁路缓存）**：最常用。
   - **写**：先更新DB，**再删除Cache**。
   - **读**：读Cache，未命中则读DB并回填Cache。
   - **问题**：在“更新DB后，删除Cache前”的极小间隙，并发读可能读到旧数据并回填。可通过**延迟双删**（更新DB后，休眠一小段时间再删一次Cache）缓解。
2. **Write Through/Write Behind**：由缓存组件负责同步写DB，对业务透明，但对缓存组件要求高。
3. **最终一致性保证**：
   - 引入**消息队列**，将删除Cache的操作异步化、重试，确保最终删除成功。
   - 使用**数据库Binlog订阅**（如Canal），异步更新/删除缓存，解耦业务代码。

**11、热key问题怎么解决**

> **你的回答**：意识到了分片和二级缓存，但“同一个key怎么分散”问到了点上，说明你思考了。
> **面试官可能评价**：对问题有感知，但缺乏系统性的解决方案库。

**修正与补充**：

1. **识别**：通过监控、客户端统计或Redis自带的`hotkeys`参数识别。
2. **解决方案**：
   - **本地缓存（二级缓存）**：在应用服务器本地缓存热key数据（如Guava Cache）。需注意本地缓存的一致性问题（设置短TTL）。
   - **Redis分片集群**：你说的对，**同一个Key无法分散**。所以解决方案是：
     - **副本扩容**：对于读热key，可以临时增加该Key所在分片的**从节点**，通过读写分离分摊压力。
     - **业务端拆分**：将热key在业务逻辑上拆分成多个子key。例如 `hot:video:1234` 拆成 `hot:video:1234:shard1`、`hot:video:1234:shard2`，客户端随机访问一个。这需要业务代码配合。

**12、分布式系统下，你觉得互斥锁有什么优缺点**

> **你的回答**：过于简略和情绪化(`٩(◕‿◕)۶` `(T_T)`)。优点不止安全，缺点分析不到位。
> **面试官可能评价**：思考停留在表面，无法进行系统性分析。

**修正与补充**：

- **优点**：
  1. **强一致性**：在临界资源访问上提供最强的一致性保证。
  2. **实现简单直观**：概念清晰，易于理解和实现基本功能。
- **缺点**：
  1. **性能瓶颈**：所有对资源的请求串行化，在高并发下吞吐量急剧下降。
  2. **复杂度高**：需要处理锁超时、释放、可重入、公平性等问题，容易出错。
  3. **可用性风险**：锁服务本身成为单点。如果锁服务故障或网络分区，可能导致系统大面积不可用。
  4. **与分布式系统理念相悖**：分布式系统设计追求**无状态**和**分区容忍性**，而分布式锁引入了强状态依赖。

**13、mysql一张表最多的存储数据数**

> **你的回答**：“不知道。” —— 可以理解，但更好的回答方式是展示你的推理思路。
> **面试官可能评价**：缺乏估算能力和技术敏感度。

**修正与补充**：
这个问题没有固定答案，取决于存储引擎和行大小。但面试官想考察你的估算能力。

- **理论限制**：对于InnoDB，如果使用默认页大小16KB，一个B+树叶子节点可存很多行。表空间文件最大可达64TB。
- **实际限制**：
  - **性能**：当数据量超过**千万级**，即使有索引，复杂查询的性能也会显著下降。单表数据量常以这个为经验参考。
  - **管理**：备份、恢复、DDL操作（如加索引）会变得非常缓慢。
- **所以，更专业的回答**：“从性能和维护角度，单表数据量建议控制在千万级别以内。如果持续增长，就需要考虑分库分表了。”

**14、mysql索引B+树的常用层数是？**

> **你的回答**：“估计两层就差不多了”——这个估计**严重偏差**，说明你对数据量级没有概念。
> **面试官可能评价**：对数据库底层结构和数据规模缺乏基本认知。

**修正与补充**：
我们来算一下：

- 假设主键是 **BigInt（8字节）**，InnoDB中一个指针（页号）约为 **6字节**。
- 一页（Page）16KB = 16384字节。
- **非叶子节点**：每对（主键+指针）约14字节。一页可存放约 `16384 / 14 ≈ 1170` 个索引项。
- **叶子节点**：存放整行数据。假设一行数据1KB，则一页可放约16行。
- **计算**：
  - 第一层（根）：1页，指向1170个页。
  - 第二层：1170页，指向 `1170 * 1170 ≈ 1.37M` 个页。
  - 第三层（叶子）：`1.37M * 16 ≈ 2190万` 行数据。
- **结论**：对于一个约2000万行的表，B+树索引**高度为3层**。对于亿级表，高度为4层。这才是合理的认知。

**15、B树和B+树的区别**

> **你的回答**：正确但不够全面。
> **面试官可能评价**：知道主要区别，但可能没有深入理解其设计目的。

**修正与补充**：

1. **数据存储位置**：B树所有节点都存数据；B+树**只有叶子节点存数据**，非叶子节点仅存键值和指针。
2. **叶子节点链接**：B树叶节点无指针链接；B+树叶节点通过双向链表串联，便于**范围查询**。
3. **查询稳定性**：B树查询可能在非叶子节点结束，不稳定；B+树任何查询都必须走到叶子节点，**速度稳定**。
4. **空间利用率**：B+树非叶子节点不存数据，**更能“撑开”树**，相同数据量下**树高更低**，I/O次数更少。

**16、threadlocal的底层实现**

> **你的回答**：“整个JVM拥有一个大Map”描述完全错误。这是对ThreadLocal最经典的误解。
> **面试官可能评价**：对Java并发基础的重要组件理解完全错误。

**修正与补充**：

- **正确结构**：**每个`Thread`对象内部**，维护了一个私有变量 `ThreadLocalMap`。
- `ThreadLocalMap` 的 **Key** 是 `ThreadLocal` 对象本身（弱引用），**Value** 是你存储的值。
- 所以，不是“一个大Map”，而是**每个线程都有自己的小Map**。这样设计避免了多线程竞争，实现了线程隔离。
- **内存泄漏风险**：Key（ThreadLocal）是弱引用，容易被GC。如果ThreadLocal对象被回收，Key会变成null，但Value是强引用，如果线程不终止（如线程池线程），这个Entry就无法访问也无法回收，造成泄漏。**必须手动调用`remove()`**。

**17、线程池的底层实现**

> **你的回答**：“不知道，不就是……”这种开场白极其糟糕。“被统一管理起来的很多线程组”概念错误。
> **面试官可能评价**：对Java并发核心工具完全不了解，态度不端正。

**修正与补充**：
Java线程池（如`ThreadPoolExecutor`）核心组件：

1. **任务队列（BlockingQueue）**：存放提交的Runnable/Callable任务。
2. **工作线程集合（HashSet<Worker>）**：Worker是封装了Thread和执行逻辑的内部类。
3. **核心线程数（corePoolSize）、最大线程数（maximumPoolSize）**。
4. **拒绝策略（RejectedExecutionHandler）**。

- **工作流程**：
  1. 提交任务，如果运行线程数 < corePoolSize，创建新线程（Worker）执行。
  2. 否则，任务放入队列。
  3. 如果队列已满，且运行线程数 < maximumPoolSize，创建新线程执行。
  4. 否则，触发拒绝策略。

**18、jvm的垃圾回收机制了解吗 & 19、具体讲一下G1**

> **你的回答**：“这个了解，方式还挺多的，不太记得了。” / “不记得了。” —— **连续两个“不记得”，面试基本可以宣告结束。** JVM是Java面试的基石。
> **面试官可能评价**：Java基础极其薄弱，不具备高级工程师的必备知识。

**修正与补充（你必须背下来）**：

- **分代收集理论**：堆内存分为新生代（Young）、老年代（Old）。新生代又分Eden、Survivor区。
- **常见GC算法**：
  - **新生代**：复制算法（Minor GC）。
  - **老年代**：标记-清除或标记-整理算法（Major GC / Full GC）。
- **G1垃圾收集器**：
  - **区域化**：将堆划分为多个大小相等的Region，新生代和老年代是逻辑概念，由一系列Region组成。
  - **核心思想**：**优先回收价值最大的Region**（即垃圾最多的Region，Garbage First名称由来）。
  - **工作流程**：分为**Young GC**、**Mixed GC**（回收新生代和部分老年代Region）、**Full GC**（备用，单线程，应避免）。
  - **优势**：可预测的停顿时间模型，整体上采用标记-整理，局部（两个Region间）采用复制算法，避免内存碎片。

**20、Ai coding和ai带给你学习上的改变**
（此题为开放题，略过，但面试中需准备好有深度的个人见解）

**21、设计一个抖音短视频点赞系统...**

> **你的回答**：有分布式和CAP的意识，但设计过于粗糙。“差一两个其实也没有影响”这种表述在设计中是危险的。缺乏**具体的技术选型、架构图、数据流**。
> **面试官可能评价**：有基本概念，但无法产出系统化、可落地的设计方案，工程化能力不足。

**修正与补充设计思路**：

1. **需求分析**：百万QPS、高可用、最终一致性、读多写多。
2. **架构分层**：
   - **接入层**：负载均衡（如LVS+NGINX）。
   - **业务层**：微服务集群（点赞服务）。**写请求异步化**：收到点赞请求后，先同步写**Redis**（记录用户-视频点赞关系），同时将点赞事件发往**消息队列**（如Kafka/RocketMQ）。
   - **存储层**：
     - **Redis**：
       - **热数据**：使用 `Hash` 结构，Key为 `video:like:{videoId}`，field为用户ID，value为时间戳。用于快速判断用户是否已点赞。
       - **计数器**：使用 `String` 结构，Key为 `count:like:{videoId}`，存储当前点赞数。使用 `INCR/DECR` 原子操作。
       - **热Key应对**：对顶级热视频（如春晚），将计数器进一步分片，如 `count:like:{videoId}:shard1` ... `shard10`，总数为各分片之和。
     - **MySQL**：作为持久化存储。**消费者**从消息队列中取出点赞事件，**批量、异步**地写入数据库。数据库表用于持久化、对账和复杂查询。
3. **一致性保障**：
   - **最终一致性**：通过消息队列保证异步落库。Redis数据是权威的“实时视图”。
   - **数据对账**：定时任务对比Redis计数与DB总数，进行修复。
4. **扩展性**：
   - Redis Cluster分片存储不同视频的数据。
   - 消息队列分区按`videoId`哈希，保证同一视频的点赞事件有序处理。

---

### **整体评价与致命问题总结**

1.  **知识浮于表面**：你似乎听过很多名词（哨兵、布隆过滤器、雪崩），但一旦追问细节（选举规则、误判类型、B+树层数）就立刻暴露。这是“面经背诵型”选手的典型特征。
2.  **核心基础严重缺失**：**JVM、并发（线程池、ThreadLocal）、MySQL索引原理**是Java后端面试的三座大山，你几乎全部失守。这会让面试官直接质疑你的编码能力和解决问题的深度。
3.  **表达极不专业**：口语化、中英文混杂、使用表情符号、说“不知道”和“随机吧”。技术沟通需要**精准、清晰、有条理**。
4.  **缺乏深入思考**：对于“为什么”（如Redis单线程）和“怎么样”（如如何设计）的问题，你倾向于给出一个最表面的结论，而没有展现背后的权衡和原理。

### **给你的补充追问（模拟面试官）**

基于你的薄弱环节，面试官一定会深入追问：

1.  **Redis**：
    - 哨兵之间是如何发现彼此的？如何选举领导者哨兵？（Raft协议）
    - 如果发生网络分区（脑裂），Redis集群会怎样？如何应对？
    - Redis的持久化机制RDB和AOF的区别？在故障恢复时如何选择？
2.  **MySQL**：
    - 为什么InnoDB表一定要有主键？如果不指定会怎样？
    - 讲一下索引下推和覆盖索引。
    - 一条SQL语句执行得很慢，你如何排查？
3.  **JVM**：
    - 对象从创建到被回收，在内存中是如何流转的？（详细说明Eden， Survivor， Old区）
    - 有哪些GC Roots？如何判断一个对象是否可以被回收？
    - G1的Mixed GC在什么时机触发？
4.  **并发**：
    - ThreadLocal的弱引用Key可能导致内存泄漏，画一下具体的引用链。
    - 线程池的各个参数如何设置？核心线程数设为0会怎样？
    - `synchronized`和`ReentrantLock`的区别？
5.  **系统设计**：
    - 你设计的点赞系统，如果消息队列消费失败，点赞数据丢失怎么办？（答：重试机制、死信队列、人工对账）
    - Redis计数器和数据库总数对账时，发现不一致，以谁为准？修复逻辑是什么？
    - 如何应对瞬时百万人给同一个视频点赞？（热Key解决方案的落地细节）

**给你的最后建议**：
**停止泛泛地看面经！** 立即采取以下行动：

1.  **深度攻坚**：针对JVM、并发、MySQL、Redis这四大块，各找一本权威书籍或一个系统的课程，**从头到尾、带着问题**去学习，并动手实践。
2.  **建立知识树**：每个知识点（如B+树），要能说出：是什么、为什么（解决了什么问题）、怎么样（如何工作）、关联什么（与其他技术的对比）。
3.  **练习表达**：将所有问题的答案，用清晰的结构（第一、第二、第三）和专业的语言写出来，然后复述。
4.  **思考大于记忆**：对于“为什么单线程”这类问题，要理解其背后的设计哲学和权衡，而不是记住“因为快”三个字。

时间紧迫，请立刻调整学习策略。字节跳动的面试非常注重底层原理和系统设计能力，以你目前的准备状态，很难通过。请务必沉下心来，弥补基础。祝好运。

## 问题

你解释一下Raft算法
扩展一下服务降级和熔断，
另外，
我说Redis有其他的进程，
还是面试官提醒我的，
因为Redis需要对于数据进行持久化，
比如说RDB就需要另开一个进程，

详细介绍一下Cache Aside 的双删策略。
消息队列最么保证最终一致性的，也请解释一下。

之后，Redis相关问题
哨兵如何发现彼此？
如何选择领导哨兵？
如何应对脑裂？
我都不知道。
因为我看的面经里面，这一块是收费的

### Redis相关漏洞

Redis Sentinel：什么是 Sentinel？ 有什么用？Sentinel 如何检测节点是否下线？主观下线与客观下线的区别？Sentinel 是如何实现故障转移的？为什么建议部署多个 sentinel 节点（哨兵集群）？Sentinel 如何选择出新的 master（选举机制）？如何从 Sentinel 集群中选择出 Leader？Sentinel 可以防止脑裂吗？Redis Cluster：为什么需要 Redis Cluster？解决了什么问题？有什么优势？Redis Cluster 是如何分片的？为什么 Redis Cluster 的哈希槽是 16384 个？如何确定给定 key 的应该分布到哪个哈希槽中？Redis Cluster 支持重新分配哈希槽吗？Redis Cluster 扩容缩容期间可以提供服务吗？Redis Cluster 中的节点是怎么进行通信的？

这一块我都不知道。

MySQL的主键应该是整体的数据的排序，
不指定，
它也会有一个隐藏的主键，
只不过排序可能不是按照我们期待的方式。

### 索引下推，

比如说 ABC的联合索引，
如果提供AB，那么也能够使用这个联合索引

### 覆盖索引

如果想要查询的数据就在ABC当中，
就不需要再查询了。

### 慢SQL

使用explain看一下执行的方式，
看一下索引是否有被使用到，

JVM和并发先放弃

### 系统设计

是的，这就是我在思考的地方
我也不知道我们的兜底机制如果都失效了
还有什么可以依赖
但是，
我们貌似只需要最终一致性
我不太理解你提供的策略。
详细解释一下三个策略

不一致，
怎么解决呢？

热点key我也不会。
可以把热点key分散一下，把它使用分片的技术，
拆成多个，
但是细节我就不太知道了。
