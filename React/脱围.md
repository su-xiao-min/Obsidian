主要是，看到了useEffect在报错，
参考「「」」，懒得找超链接了，反正有就是了。
[脱围机制（Escape Hatches） – React 中文文档](https://zh-hans.react.dev/learn/escape-hatches)
官方文档写的不错，
虽然是中文的，
虽然我看不懂英文。

当然，
在学习useEffect之前，我们先学习how to remove unnessesary effect.

```typescript
function Form() {  

const [firstName, setFirstName] = useState('Taylor');  

const [lastName, setLastName] = useState('Swift');  

  

// 🔴 避免：多余的 state 和不必要的 Effect  

const [fullName, setFullName] = useState('');  

useEffect(() => {  

setFullName(firstName + ' ' + lastName);  

}, [firstName, lastName]);  

// ...  

}
```
确实多余，反正本来就要重新渲染，

## 哲学

让我们来学习一下[React 哲学 – React 中文文档](https://zh-hans.react.dev/learn/thinking-in-react#step-3-find-the-minimal-but-complete-representation-of-ui-state)

在 React 中有两种“模型”数据：props 和 state。下面是它们的不同之处:

- [**props** 像是你传递的参数](https://zh-hans.react.dev/learn/passing-props-to-a-component) 至函数。它们使父组件可以传递数据给子组件，定制它们的展示。举个例子，`Form` 可以传递 `color` prop 至 `Button`。
- [**state** 像是组件的内存](https://zh-hans.react.dev/learn/state-a-components-memory)。它使组件可以对一些信息保持追踪，并根据交互来改变。举个例子，`Button` 可以保持对 `isHovered` state 的追踪。

props 和 state 是不同的，但它们可以共同工作。父组件将经常在 state 中放置一些信息（以便它可以改变），并且作为子组件的属性 **向下** 传递至它的子组件。如果第一次了解这其中的差别感到迷惑，也没关系。通过大量练习即可牢牢记住！

太有趣了，props vs state，现代的无状态应用。



话说，什么叫做脱围呢？

你扮演一个犀利、毒舌的前端多年经验的开发者，点评一下我后面的理解，
再提出一些问题
包括
1. 技术细节问题，考察我对于React 使用的能力
2. 技术设计问题，考察我对于React哲学的理解
3. 系统架构问题，考察我的知识迁移能力
我先谈一下我对于两个Hook的理解，
首先是useEffect，
感觉这是一个非常容易被滥用的函数，
它本意是处理React应用和外部系统的交互的，
但是，在很多地方都被滥用的。
它的方式是直接申明
```ts
useEffect(fn, [depencies])
```
效果就是，出现了依赖的变化的时候，
重新执行函数。
注意，使用useEffect还需要处理闭包的问题，如果fn的内容调用了函数，函数有自己的闭包的参数，
那么，它就需要被添加到依赖当中，
不添加，
就不监听
意味着，fn就调用原来的函数。

useCallback则是生成一个稳定的函数，
避免每次渲染的时候都更新，
一般可以用来useEffect当中。

React当中的渲染应该是每次页面跳转的时候
渲染的时候，
基本上整个页面的东西都需要重新计算，

除了整体的渲染，
页面还可以局部渲染。

