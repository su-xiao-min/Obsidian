主要是，看到了useEffect在报错，
参考「「」」，懒得找超链接了，反正有就是了。
[脱围机制（Escape Hatches） – React 中文文档](https://zh-hans.react.dev/learn/escape-hatches)
官方文档写的不错，
虽然是中文的，
虽然我看不懂英文。

当然，
在学习useEffect之前，我们先学习how to remove unnessesary effect.

```typescript
function Form() {  

const [firstName, setFirstName] = useState('Taylor');  

const [lastName, setLastName] = useState('Swift');  

  

// 🔴 避免：多余的 state 和不必要的 Effect  

const [fullName, setFullName] = useState('');  

useEffect(() => {  

setFullName(firstName + ' ' + lastName);  

}, [firstName, lastName]);  

// ...  

}
```
确实多余，反正本来就要重新渲染，

## 哲学

让我们来学习一下[React 哲学 – React 中文文档](https://zh-hans.react.dev/learn/thinking-in-react#step-3-find-the-minimal-but-complete-representation-of-ui-state)

在 React 中有两种“模型”数据：props 和 state。下面是它们的不同之处:

- [**props** 像是你传递的参数](https://zh-hans.react.dev/learn/passing-props-to-a-component) 至函数。它们使父组件可以传递数据给子组件，定制它们的展示。举个例子，`Form` 可以传递 `color` prop 至 `Button`。
- [**state** 像是组件的内存](https://zh-hans.react.dev/learn/state-a-components-memory)。它使组件可以对一些信息保持追踪，并根据交互来改变。举个例子，`Button` 可以保持对 `isHovered` state 的追踪。

props 和 state 是不同的，但它们可以共同工作。父组件将经常在 state 中放置一些信息（以便它可以改变），并且作为子组件的属性 **向下** 传递至它的子组件。如果第一次了解这其中的差别感到迷惑，也没关系。通过大量练习即可牢牢记住！

太有趣了，props vs state，现代的无状态应用。



话说，什么叫做脱围呢？

你扮演一个犀利、毒舌的前端多年经验的开发者，点评一下我后面的理解，
再提出一些问题
包括
1. 技术细节问题，考察我对于React 使用的能力
2. 技术设计问题，考察我对于React哲学的理解
3. 系统架构问题，考察我的知识迁移能力
我先谈一下我对于两个Hook的理解，
首先是useEffect，
感觉这是一个非常容易被滥用的函数，
它本意是处理React应用和外部系统的交互的，
但是，在很多地方都被滥用的。
它的方式是直接申明
```ts
useEffect(fn, [depencies])
```
效果就是，出现了依赖的变化的时候，
重新执行函数。
注意，使用useEffect还需要处理闭包的问题，如果fn的内容调用了函数，函数有自己的闭包的参数，
那么，它就需要被添加到依赖当中，
不添加，
就不监听
意味着，fn就调用原来的函数。

useCallback则是生成一个稳定的函数，
避免每次渲染的时候都更新，
一般可以用来useEffect当中。

React当中的渲染应该是每次页面跳转的时候
渲染的时候，
基本上整个页面的东西都需要重新计算，

除了整体的渲染，
页面还可以局部渲染。


### 在事件处理函数中共享逻辑 [](https://zh-hans.react.dev/learn/you-might-not-need-an-effect#sharing-logic-between-event-handlers "Link for 在事件处理函数中共享逻辑")

假设你有一个产品页面，上面有两个按钮（购买和付款），都可以让你购买该产品。当用户将产品添加进购物车时，你想显示一个通知。在两个按钮的 click 事件处理函数中都调用 `showNotification()` 感觉有点重复，所以你可能想把这个逻辑放在一个 Effect 中：

```
function ProductPage({ product, addToCart }) {  // 🔴 避免：在 Effect 中处理属于事件特定的逻辑  useEffect(() => {    if (product.isInCart) {      showNotification(`已添加 ${product.name} 进购物车！`);    }  }, [product]);  function handleBuyClick() {    addToCart(product);  }  function handleCheckoutClick() {    addToCart(product);    navigateTo('/checkout');  }  // ...}
```

这个 Effect 是多余的。而且很可能会导致问题。例如，假设你的应用在页面重新加载之前 “记住” 了购物车中的产品。如果你把一个产品添加到购物车中并刷新页面，通知将再次出现。每次刷新该产品页面时，它都会出现。这是因为 `product.isInCart` 在页面加载时已经是 `true` 了，所以上面的 Effect 每次都会调用 `showNotification()`。

**当你不确定某些代码应该放在 Effect 中还是事件处理函数中时，先自问 为什么 要执行这些代码。Effect 只用来执行那些显示给用户时组件 需要执行 的代码**。在这个例子中，通知应该在用户 **按下按钮** 后出现，而不是因为页面显示出来时！删除 Effect 并将共享的逻辑放入一个被两个事件处理程序调用的函数中：

```
function ProductPage({ product, addToCart }) {  // ✅ 非常好：事件特定的逻辑在事件处理函数中处理  function buyProduct() {    addToCart(product);    showNotification(`已添加 ${product.name} 进购物车！`);  }  function handleBuyClick() {    buyProduct();  }  function handleCheckoutClick() {    buyProduct();    navigateTo('/checkout');  }  // ...}
```

这既移除了不必要的 Effect，又修复了问题。
看不懂一点