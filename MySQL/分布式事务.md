参考[ni’en](https://zhuanlan.zhihu.com/p/610552000)
事务分为
- 本地事务，一定要保持ACID，
- 分布式事务。

分布式事务有着CAP的限制，
换言之，
它为了保持分区容错性
要么牺牲一致性
要么牺牲可用性

分布式事务 vs 分布式锁
分布式事务解决的是事务


数据一致性和高性能是矛盾
你必须要trade-off，权衡取舍。

性能好 -> 一致性很差
一致性好好 -> 性能很差。

InnoDB通过锁来和日志保持ACID

锁，保证隔离性
redo log，持久性
undo log 原子性 & 一致性 

实际上就是写的间接化，
也就是性能和一致性的取舍。
你永远解决不了这个问题，
但是，
选择去解决，
本身就意味着问题有转机，

## 分布式事务

当「本地事务」 -> 「分布式事务」，
问题变得更加复杂。
一个数据需要多个DB。
一个操作拆分到多个服务。
不存在可靠的解决策略，
但是，具体问题具体分析。

## 场景

### 跨库场景

### 分库分表

### 微服务 

## CAP理论

分布式事务当中必须要满足
分区容错性 Partition tolerance -> 单个组件无法使用，操作依然可以完成。

之后就是在 
一致性 Consistency 
vs
可用性 Availability 
之间进行取舍。

一致性分为
1. 强一致性
2. 最终一致性
3. 弱一致性

可用性包括
1. 一定时间内
2. 返回正常结果

我们肯定是不能放弃分区容错性的，
往往是放弃强一致性，
保持最终一致性，
来实现可用性。

## BASE定理

即使无法做到强一致性 Strong Consistency，
但是可以通过策略，
实现最终一致性 Eventual Consistency，

1. Basically Available
2. Soft State
3. Eventual Consistency
  1. 因果一致性
  2. 读自己写的内容
  3. 会话已执行
  4. 单调读一致
  5. 单调写一致

## 分类

### 刚性事务

即，满足CP ，放弃 Available

### 柔性事务

即，满足BASE 
适合低并发
短事务

通过两端提交，
保持分布式事务的完整性。

## 刚性事务的实现

后面就不太看得懂了，
不过，
最终，我们都是权衡取舍，
另外，我的项目其实使用的还不是分布式事务，
我的项目需要的只是重试而已，
换言之，Elasticsearch只是视图。
写进MySQL，一切就可以开心快乐了。
之后，只要我们重试，只要我们重试。

## 柔性事务的细节

## 特性 

- 基本可用
- 柔性状态 

### 分类

1. 补偿型-同步
2. 通知型-异步

### 通知型事务

1. 异步更新数据
2. 对于数据要求比较低

- 异步确保性事务，内部，最终一致性。
- 最大努力通知，外部，不可靠，需要对方自己兜底。

#### 异步确保型事务

1. MQ 
2. 本地消息表 

#### 最大努力通知

通过定期校验机制 -> 保障最终一致性。

1. MQ事务消息
2. 本地方法表

#### 问题 
问题 
消息发送一致性
换言之，我们通过发消息来保证一致性
但是，我们怎么保证我们成功发了消息呢？
即，我们期待实现
业务动作 -> 发送消息。
