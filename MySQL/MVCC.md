## 并发控制机制

「读写分离实在是伟大的策略！」

是通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，MVCC 会为该事务创建一个数据快照，而不是直接修改实际的数据行。

读操作。

写操作，为什么写操作之后还要保留原来的原本的数据，这样不会错乱吗？

我的理解是，这样可以解决幻读问题，你知道你读取数据之后，数据已经发生了改变，如果你要重复进行聚合操作，那么就使用你上一次聚合的时候的版本的数据。

事物的提交和回滚。

![](assets/MVCC/file-20260118205109366.png)

好奇怪啊，有时候你可以支持即时渲染……略过，不解决这个问题。

也就是说，存在三种模型，即时渲染，源码，只读。

版本的回收。

[**一致性非锁定读（Consistent Nonlocking Reads）**](https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html)，即，快照读。读取历史数据，不需要等待锁的释放。

锁定度。当前读。

怎么实现MVCC，通过影藏字段。

事物ID

回滚指针。

局促索引。